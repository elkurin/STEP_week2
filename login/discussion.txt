O(1)のハッシュよりO(logN)の二分木の方が使われる理由

1. 適切なハッシュ関数を探すのが難しい
どんな場合にでも対応出来るよう機械的にハッシュ関数を定めるとすると、例えばa~zの26文字を使って10文字以内とするなら、27 ** 10 - 1 通り存在することになる。つまりそれだけ区別しなくてはならないので、1e+40程度の容量が必要になる。これは非常に非効率的かつメモリ不足で不可能。ゆえに、その場その場で被りが出ないような適切なハッシュ関数を設ける必要がある。これは機械的に行うのは難しく、その上新しいユーザーが登録する度に被りがないかチェックし、もし被りがあれば関数を考え直す必要があり、大変。
一方、二分木ならば、ただただユーザーを機械的に加えていくだけで良いので、単純で楽。またO(logN)ならそんなに悪くない。

2. メモリを余分に用意する必要がある
二分木の場合、ユーザーの数と常に連動してメモリを増やせば良い。しかし、ハッシュ関数で管理する場合は、ユーザーが増える度に関数を変えるのでなければ、最初にかなり大きめにメモリを用意する必要がある。これが非効率的。また、人が増えてくればそれに応じてハッシュテーブルを増やしたりする作業が必要で、面倒。

3. ハッシュではキーの長さに強く依存する
キーが非常に長い場合、キーの長さに依存すると結構時間がかかる。ハッシュテーブルを使うとき、キーの全ての文字を確認しなくてハッシュ関数で計算させることになる。
一方で二分木では、あるノードのキーと比較する際に、全ての文字を比較する必要はなく、大小が決定する文字まで確認したらそのあとは見なくてよい。さらに、その下位のノードでは、既に大小が決定した文字については見なくても良く、結果的に比較する文字の合計はキーの文字数をKとすると高々 logN + K となる。つまり、ユーザー名が異常に長く、かつユーザーが大していない場合には計算量の差は誤差程度になる。

4. まとめて取り出すには二分木の方が速い場合がある
二分木ではユーザーを整列させて保存できているので、例えばユーザー番号n~mといったとき、nのユーザーとmのユーザーを探せば十分であとはその間を取り出せば良い。一方、ハッシュテーブルで管理している場合は無秩序に並んでいるので、n~mを探すにはそれぞれにユーザーを探し出す必要があり、非効率的。
